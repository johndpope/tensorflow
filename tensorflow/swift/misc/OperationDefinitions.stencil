// This file is generated automatically, DO NOT EDIT
//  tensorflow/core/framework/op_def.proto
//  tensorflow/core/framework/op_def.pb.swift
//  https://github.com/tensorflow/tensorflow/blob/c9428db01eec1c457d9451ef1ca550b634bddf60/tensorflow/go/op/wrappers.go

import Foundation
import Darwin.C.stddef
import Darwin.C.stdint
import CTensorFlow
import protoTensorFlow

/*
var _inputArg: [Tensorflow_OpDef.ArgDef] = []
var _outputArg: [Tensorflow_OpDef.ArgDef] = []
var _attr: [Tensorflow_OpDef.AttrDef] = []
var _deprecation: Tensorflow_OpDeprecation? = nil
var _summary: String = String()
var _description_p: String = String()
var _isCommutative: Bool = false
var _isAggregate: Bool = false
var _isStateful: Bool = false
var _allowsUninitializedInput: Bool = false
*/

{% for op in operations %}

/*
{{op._storage._summary}}

{{op._storage._description_p}}

_inputArg
{% for arg in op._storage._inputArg %} {{arg.name}}:{{arg.type}}: .{{arg.typeAttr}} {% endfor %}
_outputArg

_outputArg
{% for arg in op._storage._outputArg %} {{arg.name}}:{{arg.type}}:{{arg.typeAttr}} {% endfor %}

*/



// TODO - in the return parameters use an index Output(0) // output(1) etc
// TODO - work out a way to skip extroneous , eg. param,param, )
// TODO - Not all return types are output eg.
// func ResourceSparseApplyRMSProp(scope *Scope, var_ tf.Output, ms tf.Output, mom tf.Output, lr tf.Output, rho tf.Output, momentum tf.Output, epsilon tf.Output, grad tf.Output, indices tf.Output, optional ...ResourceSparseApplyRMSPropAttr) (o *tf.Operation)


{% macro returnParametersBlock types %}{% for type in types %}{{type.name}}: tf.Output{% if not forloop.last %}, {% endif %}{% endfor %}{% endmacro %}

{% macro parametersBlock types %}{% for type in types %}{{type.name}}: tf.Output{% if not forloop.last %}, {% endif %}{% endfor %}{% endmacro %}

{% macro returnBlock types %}{% for type in types %}op.Output({{forloop.counter}}){% if not forloop.last %},{% endif %}{% endfor %}{% endmacro %}

func {{ op._storage._name|lowerFirstWord}}(scope:Scope,{% call parametersBlock op._storage._inputArg %})  -> ({% call returnParametersBlock op._storage._outputArg %}){
    if scope.error() != nil {
        return
    }


    let opspec = tf.OpSpec(
        Type: "{{ op._storage._name}}",
        Input: [ {% for arg in op._storage._inputArg %} {{arg.name}},{{arg.type}} {% endfor %})]
        Attrs: attrs
    )



    {% if op._storage._outputArg.count %}
        let op = scope.AddOperation(opspec)
        return ({% call returnBlock op._storage._outputArg %})
    {% endif %}

}
{% endfor %}

